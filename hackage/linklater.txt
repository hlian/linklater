-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A Haskell library for the Slack API
--   
--   <a>~please see our lovely README.md~</a>
@package linklater
@version 4.0.0.0

module Network.Linklater.Types

-- | The unique 'C&lt;number&gt;' Slack assigns to each channel. Used to
--   <tt>say</tt> things.
type ChannelID = Text

-- | Where <tt>slash</tt> commands come from and where <a>Message</a>s go.
data Channel
Channel :: !ChannelID -> !Text -> Channel

-- | A username: no at-signs, just text!
newtype User
User :: Text -> User

-- | Incoming HTTP requests to the slash function get parsed into one of
--   these babies.
data Command
Command :: !Text -> !User -> !Channel -> !(Maybe Text) -> Command

-- | The command name.
[_commandName] :: Command -> !Text

-- | Who ran your slash command.
[_commandUser] :: Command -> !User

-- | Where the person ran your slash command.
[_commandChannel] :: Command -> !Channel

-- | Text for the slash command, if any.
[_commandText] :: Command -> !(Maybe Text)

-- | The icon next to the messages you <tt>say</tt>. (Images unsupported
--   right now, sorry.)
newtype Icon

-- | For example, ":stars2:".
EmojiIcon :: Text -> Icon

-- | A little DSL for <a>Slack formatting</a>.
data Format

-- | <pre>
--   "&lt;@user|user&gt;"
--   </pre>
FormatAt :: !User -> Format

-- | <pre>
--   "&lt;@user|user did this and that&gt;"
--   </pre>
FormatUser :: !User -> !Text -> Format

-- | <pre>
--   "&lt;http://example.com|user did this and that&gt;"
--   </pre>
FormatLink :: !Text -> !Text -> Format

-- | <pre>
--   "user did this &amp;amp; that"
--   </pre>
FormatString :: !Text -> Format

-- | Here's how you talk: you make one of these and pass it to
--   <tt>say</tt>. Before the day is done, Linklater will convert this to a
--   JSON blob using <a>Aeson</a>.
--   
--   <ul>
--   <li>Simple messages are parsed by Slack with parse=full (i.e. as if
--   you had typed it into the input box).</li>
--   <li>Complex messages are parsed according to Slack formatting. See
--   <a>Format</a>.</li>
--   </ul>
data Message
SimpleMessage :: !Icon -> !Text -> !Channel -> !Text -> Message
FormattedMessage :: !Icon -> !Text -> !Channel -> ![Format] -> Message

-- | Like a curiosity about the world, you'll need one of these to
--   <tt>say</tt> something.
data Config
Config :: !Text -> Config

-- | This is the incoming web hook URL that Slack gave you. It's usually
--   <tt><a>https://hooks.slack.com/services/..</a>.</tt>.
[_configHookURL] :: Config -> !Text

-- | An API token, either a tester token or one obtained through OAuth.
--   
--   See:
--   
--   <ul>
--   
--   <li><pre><a>https://api.slack.com/docs/oauth-test-tokens</a></pre></li>
--   <li><pre><a>https://api.slack.com/docs/oauth</a></pre></li>
--   </ul>
newtype APIToken
APIToken :: Text -> APIToken
type Response = Response ByteString

-- | Rather than throwing unchecked exceptions from our HTTP requests, we
--   catch all unchecked exceptions and convert them to checked
--   <a>RequestError</a> values.
data RequestError
RequestError :: !(Maybe SomeException) -> !(Maybe Response) -> !(Maybe String) -> RequestError

-- | An unchecked exception, typically <a>IOException</a>, occurred
[_requestErrorException] :: RequestError -> !(Maybe SomeException)

-- | Something awry with the response, typically a non-2xx response
[_requestErrorResponse] :: RequestError -> !(Maybe Response)

-- | Something awry with the JSON decoding
[_requestErrorDecoding] :: RequestError -> !(Maybe String)
unformat :: Format -> Text
commandOfParams :: Map Text Text -> Either String Command
tryRequest :: (MonadIO m, MonadError RequestError m) => IO Response -> m Response
promoteEither :: MonadError RequestError m => Response -> (l -> String) -> Either l r -> m r
promoteMaybe :: MonadError RequestError m => Response -> String -> Maybe r -> m r
asList :: [a] -> [a]
instance GHC.Show.Show Network.Linklater.Types.RequestError
instance GHC.Classes.Ord Network.Linklater.Types.APIToken
instance GHC.Classes.Eq Network.Linklater.Types.APIToken
instance GHC.Show.Show Network.Linklater.Types.APIToken
instance GHC.Show.Show Network.Linklater.Types.Icon
instance GHC.Classes.Ord Network.Linklater.Types.Icon
instance GHC.Classes.Eq Network.Linklater.Types.Icon
instance GHC.Show.Show Network.Linklater.Types.Command
instance GHC.Classes.Ord Network.Linklater.Types.Command
instance GHC.Classes.Eq Network.Linklater.Types.Command
instance GHC.Show.Show Network.Linklater.Types.User
instance GHC.Classes.Ord Network.Linklater.Types.User
instance GHC.Classes.Eq Network.Linklater.Types.User
instance GHC.Show.Show Network.Linklater.Types.Channel
instance GHC.Classes.Ord Network.Linklater.Types.Channel
instance GHC.Classes.Eq Network.Linklater.Types.Channel
instance Data.Aeson.Types.Class.ToJSON Network.Linklater.Types.Channel
instance Data.Aeson.Types.Class.ToJSON Network.Linklater.Types.Message

module Network.Linklater.Batteries


-- | Here's a <tt>/jpgto</tt> bot! If you run this program and then tell
--   Slack about your server (incoming hook and custom slash command) and
--   then type <tt>/jpgto baby corgi</tt> in one of your channels, you'll
--   get the image from <tt><a>http://baby.corgi.jpg.to</a></tt>.
--   
--   
--   <a>https://github.com/hlian/linklater/blob/master/examples/JointPhotographicExpertsGroupTonga.hs</a>
--   
--   One <tt>/jpgto baby corgi</tt>, et voila.
--   
module Network.Linklater

-- | Where <tt>slash</tt> commands come from and where <a>Message</a>s go.
data Channel
Channel :: !ChannelID -> !Text -> Channel

-- | A username: no at-signs, just text!
newtype User
User :: Text -> User

-- | Here's how you talk: you make one of these and pass it to
--   <tt>say</tt>. Before the day is done, Linklater will convert this to a
--   JSON blob using <a>Aeson</a>.
--   
--   <ul>
--   <li>Simple messages are parsed by Slack with parse=full (i.e. as if
--   you had typed it into the input box).</li>
--   <li>Complex messages are parsed according to Slack formatting. See
--   <a>Format</a>.</li>
--   </ul>
data Message
SimpleMessage :: !Icon -> !Text -> !Channel -> !Text -> Message
FormattedMessage :: !Icon -> !Text -> !Channel -> ![Format] -> Message

-- | Like a curiosity about the world, you'll need one of these to
--   <tt>say</tt> something.
data Config
Config :: !Text -> Config

-- | This is the incoming web hook URL that Slack gave you. It's usually
--   <tt><a>https://hooks.slack.com/services/..</a>.</tt>.
[_configHookURL] :: Config -> !Text

-- | Incoming HTTP requests to the slash function get parsed into one of
--   these babies.
data Command
Command :: !Text -> !User -> !Channel -> !(Maybe Text) -> Command

-- | The command name.
[_commandName] :: Command -> !Text

-- | Who ran your slash command.
[_commandUser] :: Command -> !User

-- | Where the person ran your slash command.
[_commandChannel] :: Command -> !Channel

-- | Text for the slash command, if any.
[_commandText] :: Command -> !(Maybe Text)

-- | The icon next to the messages you <tt>say</tt>. (Images unsupported
--   right now, sorry.)
newtype Icon

-- | For example, ":stars2:".
EmojiIcon :: Text -> Icon

-- | A little DSL for <a>Slack formatting</a>.
data Format

-- | <pre>
--   "&lt;@user|user&gt;"
--   </pre>
FormatAt :: !User -> Format

-- | <pre>
--   "&lt;@user|user did this and that&gt;"
--   </pre>
FormatUser :: !User -> !Text -> Format

-- | <pre>
--   "&lt;http://example.com|user did this and that&gt;"
--   </pre>
FormatLink :: !Text -> !Text -> Format

-- | <pre>
--   "user did this &amp;amp; that"
--   </pre>
FormatString :: !Text -> Format

-- | I POST a <a>Message</a> to Slack and return the HTTP response.
--   However, I need a <a>Config</a> (containing an incoming hook
--   configured through Slack administration) first.
--   
--   Guaranted to not throw an unchecked exception.
say :: (MonadError RequestError m, MonadIO m) => Message -> Config -> m ()

-- | I GET a WebSocket <tt>URI</tt> from Slack's real-time messaging
--   endpoint. However, I need an <a>APIToken</a> (configured through Slack
--   administration) first.
--   
--   Guaranted to not throw an unchecked exception.
startRTM :: (MonadError RequestError m, MonadIO m) => APIToken -> m URI
startRTMWithOptions :: (MonadError RequestError m, MonadIO m) => Options -> m URI

-- | A bot server! As if by magic. This acts like a <a>WAI</a> middleware:
--   Linklater wraps around your application. (Really, it just gives you a
--   <a>Command</a> to work with instead of a raw HTTP request.)
slash :: (Command -> Application) -> Application

-- | A bot server for people who are in a hurry. Make a function that takes
--   a <a>Command</a> and returns some <a>Text</a> in <a>IO</a> world, and
--   we'll convert it into a <a>WAI</a> application. If you want more
--   control over the request and respond, see <a>slash</a>.
slashSimple :: (Command -> IO Text) -> Application
